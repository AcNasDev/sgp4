--- a/earth_model.h
+++ b/earth_model.h
@@ -0,0 +1,30 @@
+#pragma once
+
+namespace EarthModel {
+    // WGS84 Constants
+    constexpr double SEMI_MAJOR_AXIS = 6378.137;          // Earth's semi-major axis (km)
+    constexpr double FLATTENING = 1.0/298.257223563;      // WGS84 flattening
+    constexpr double SEMI_MINOR_AXIS = SEMI_MAJOR_AXIS * (1.0 - FLATTENING);
+    constexpr double ECCENTRICITY_SQ = FLATTENING * (2.0 - FLATTENING);
+
+    // Earth's Gravitational Model
+    constexpr double GM = 398600.4418;                    // Earth's gravitational constant (km³/s²)
+    constexpr double J2 = 1.082629E-3;                    // J2 perturbation coefficient
+    constexpr double J3 = -2.53881E-6;                    // J3 perturbation coefficient
+    constexpr double J4 = -1.65597E-6;                    // J4 perturbation coefficient
+
+    // Earth Rotation
+    constexpr double OMEGA_E = 7.292115E-5;               // Earth's rotation rate (rad/sec)
+
+    struct PolarMotion {
+        double xp;    // X pole position (arcseconds)
+        double yp;    // Y pole position (arcseconds)
+        double dut1;  // UT1-UTC difference (seconds)
+
+        // Default modern values (should be updated with IERS data)
+        PolarMotion() : xp(0.162), yp(0.358), dut1(0.1789) {}
+    };
+}
--- a/coordinate_transform.h
+++ b/coordinate_transform.h
@@ -0,0 +1,65 @@
+#pragma once
+#include "earth_model.h"
+#include <cmath>
+
+class CoordinateTransform {
+public:
+    struct GeodeticCoord {
+        double latitude;   // degrees
+        double longitude;  // degrees
+        double altitude;   // kilometers
+    };
+
+    static GeodeticCoord ecefToGeodetic(const Vector3& ecef) {
+        const double& a = EarthModel::SEMI_MAJOR_AXIS;
+        const double& b = EarthModel::SEMI_MINOR_AXIS;
+        const double e2 = EarthModel::ECCENTRICITY_SQ;
+
+        const double p = std::sqrt(ecef.x*ecef.x + ecef.y*ecef.y);
+        const double theta = std::atan2(ecef.z*a, p*b);
+
+        const double sin_theta = std::sin(theta);
+        const double cos_theta = std::cos(theta);
+
+        const double lat = std::atan2(
+            ecef.z + e2*(a/b)*a*std::pow(sin_theta, 3),
+            p - e2*a*std::pow(cos_theta, 3)
+        );
+
+        const double lon = std::atan2(ecef.y, ecef.x);
+
+        const double sin_lat = std::sin(lat);
+        const double N = a / std::sqrt(1.0 - e2*sin_lat*sin_lat);
+        const double alt = p/std::cos(lat) - N;
+
+        constexpr double RAD_TO_DEG = 180.0/M_PI;
+        return {
+            lat * RAD_TO_DEG,
+            lon * RAD_TO_DEG,
+            alt
+        };
+    }
+
+    static Vector3 applyPolarMotion(const Vector3& ecef, const EarthModel::PolarMotion& pm) {
+        const double xp_rad = pm.xp * (M_PI/(180.0*3600.0));
+        const double yp_rad = pm.yp * (M_PI/(180.0*3600.0));
+
+        Vector3 result;
+        result.x = ecef.x - yp_rad*ecef.z;
+        result.y = ecef.y + xp_rad*ecef.z;
+        result.z = ecef.z + yp_rad*ecef.x - xp_rad*ecef.y;
+
+        return result;
+    }
+};
--- a/sgp4.h
+++ b/sgp4.h
@@ -3,6 +3,8 @@
 
 #include "tle.h"
 #include <cmath>
+#include "earth_model.h"
+#include "coordinate_transform.h"
 
 class SGP4 {
 public:
@@ -10,11 +12,6 @@ class SGP4 {
 
     OrbitalState getPosition(const QDateTime& time) const;
 
-private:
-    struct PolarMotion {
-        double xp; // в угловых секундах
-        double yp; // в угловых секундах
-    };
     static constexpr double XKE = std::sqrt(3600.0 * EarthModel::GM / 
                                           std::pow(EarthModel::SEMI_MAJOR_AXIS*1000.0, 3));
     static constexpr double XKMPER = EarthModel::SEMI_MAJOR_AXIS;
@@ -34,6 +31,43 @@ private:
     double xnodot_;
     double xnodp_;
 
+    double solveKepler(double M, double e, double tolerance = 1e-14) const {
+        double E = M;
+        double delta;
+        int iterations = 0;
+        const int MAX_ITERATIONS = 50;
+
+        do {
+            delta = (M + e * std::sin(E) - E) / (1.0 - e * std::cos(E));
+            E += delta;
+            iterations++;
+        } while (std::abs(delta) > tolerance && iterations < MAX_ITERATIONS);
+
+        return E;
+    }
+
+    double calculateGMST(const QDateTime& time) const {
+        // Convert to Julian Date
+        double jd = time.toMSecsSinceEpoch() / (1000.0 * 86400.0) + 2440587.5;
+        double t = (jd - 2451545.0) / 36525.0;
+
+        // GMST calculation (IAU 2006)
+        double gmst = 67310.54841 + 
+                     (876600.0 * 3600.0 + 8640184.812866) * t +
+                     0.093104 * t*t -
+                     6.2e-6 * t*t*t;
+
+        // Convert to degrees and normalize
+        gmst = std::fmod(gmst / 240.0, 360.0);
+        if (gmst < 0) gmst += 360.0;
+
+        return gmst * M_PI/180.0;
+    }
+
+    void validateResults(const CoordinateTransform::GeodeticCoord& geo) const {
+        bool valid = (std::abs(geo.latitude) <= 90.0) && (std::abs(geo.longitude) <= 180.0);
+        bool altitudeWarning = (geo.altitude < 0.0 || geo.altitude > 50000.0);
+        qDebug() << "Coordinate validation:" << (valid ? "PASSED" : "FAILED") << (altitudeWarning ? " (Altitude warning!)" : "");
+    }
     void calculatePerturbations(double tsince, Vector3 &pos, Vector3 &vel) const;
 };
 --- a/sgp4.cpp
+++ b/sgp4.cpp
@@ -1,5 +1,6 @@
 #include "sgp4.h"
 #include <QDebug>
+#include "coordinate_transform.h"
 
 SGP4::SGP4(const TLE& tle) : tle_(tle) {
     initializeParameters();
@@ -49,3 +50,31 @@ void SGP4::calculateConstants() {
     omgdot_ = temp2 * tle_.no;
     xnodot_ = temp3 * tle_.no;
 }
+
+OrbitalState SGP4::getPosition(const QDateTime& time) const {
+    Vector3 pos, vel;
+    calculatePerturbations(tsince, pos, vel);
+
+    // Apply polar motion correction
+    EarthModel::PolarMotion pm;
+    pos = CoordinateTransform::applyPolarMotion(pos, pm);
+
+    // Calculate GMST with improved accuracy
+    double gmst = calculateGMST(time);
+
+    // Apply Earth rotation
+    double c = std::cos(gmst);
+    double s = std::sin(gmst);
+
+    OrbitalState result;
+    result.position.x = pos.x * c + pos.y * s;
+    result.position.y = -pos.x * s + pos.y * c;
+    result.position.z = pos.z;
+
+    // Transform velocity
+    result.velocity.x = vel.x * c + vel.y * s - EarthModel::OMEGA_E * result.position.y;
+    result.velocity.y = -vel.x * s + vel.y * c + EarthModel::OMEGA_E * result.position.x;
+    result.velocity.z = vel.z;
+
+    return result;
+}
